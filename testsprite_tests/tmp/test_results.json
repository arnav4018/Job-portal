[
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "07e1993a-794d-44d1-8a30-e95540c7a06d",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC001-Email/Password Authentication Success",
    "description": "Verify users can successfully sign up and sign in using valid email/password credentials for each role (Candidate, Recruiter, Admin, Expert).",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign Up to navigate to the sign up page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill in full name, email, password, and select role Candidate for sign up\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Candidate')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down more to reveal the 'Create Account' button as an interactive element or extract page content to locate the button for clicking.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Try to click the 'Create Account' button by clicking the visible text or the button area using alternative methods or retry clicking the 'Sign Up' button in the header to refresh the page and retry.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the role selector button to change role back to 'Job Seeker / Candidate'.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Job Seeker / Candidate' option to change role back to Candidate.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Create Account' button at index 11 to submit the sign up form for Candidate role.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The signup and signin test for the Candidate role could not be completed successfully because the 'Create Account' button does not submit the form or navigate to the dashboard. The form remains on the signup page with all fields filled and no success indication. Due to this blocking issue, signup and signin flows for Recruiter, Admin, and Expert roles were not tested. Please investigate the signup form submission functionality. Task is incomplete.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/auth/signup:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808364766688//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:46.923Z",
    "modified": "2025-09-02T10:19:24.954Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "0c2ed61e-9e04-449a-816a-e6545f3490be",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC002-Email/Password Authentication Failure",
    "description": "Verify authentication fails with invalid credentials or missing inputs and appropriate error messages are shown.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the Sign In link to go to the sign in page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input invalid email and password, then submit the login form\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to sign in page to retry invalid login and check for error message\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input invalid email and incorrect password, then submit the login form\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Authentication did not behave as expected with invalid credentials or missing inputs.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical issue: invalid login attempts redirect to homepage without error messages, blocking verification of authentication failure handling.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808154803079//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:46.929Z",
    "modified": "2025-09-02T10:15:54.971Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "eed6681d-fa78-48ea-a1bd-7fa78866738d",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC003-Google OAuth Authentication Success",
    "description": "Verify users can sign in and sign up using Google OAuth for all roles and are routed correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Sign In' link to go to sign in page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Continue with Google' button to start OAuth flow.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate selecting a Google account to complete OAuth flow.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input test Google account email to proceed with OAuth sign-in.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/c-wiz/main/div[2]/div/div/div/form/span/section/div/div/div/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/c-wiz/main/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Expected result unknown, forcing failure.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing of Google OAuth sign-in and sign-up flows could not be completed due to Google blocking the sign-in with a security error. The app's OAuth integration cannot be fully verified under current conditions. Please address the OAuth sign-in security issue to enable testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 401 () (at https://job-portal-lgb9-fibzabxg2-arnav4018s-projects.vercel.app/api/auth/signin?csrf=true:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://accounts.google.com/gsi/status?client_id=258013614557-nema0dumfbottebi6to7aqi85qot9pvs.apps.googleusercontent.com&cas=2w6emFbVF6tAY5IfnwLnJN8sTW3J5VJZeogqea4NfII&is_itp=false:0:0)\n[ERROR] malformed JSON response: <html lang=\"en\" dir=ltr><meta charset=utf-8><meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\"><title>Error 400 (Bad Request)!!1</title><style nonce=\"QWhjDovw61Ppkal1O791rA\">*{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{color:#222;text-align:unset;margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px;}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}pre{white-space:pre-wrap;}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}</style><main id=\"af-error-container\" role=\"main\"><a href=//www.google.com><span id=logo aria-label=Google role=img></span></a><p><b>400.</b> <ins>That’s an error.</ins><p>The server cannot process the request because it is malformed. It should not be retried. <ins>That’s all we know.</ins></main> (at https://vercel.com/_next/static/chunks/ef0ef1437104491b.js?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd:2:106200)\n[WARNING] Deprecated API for given entry type. (at https://vercel.com/_next/static/chunks/800cce4ac364cacc.js?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd:19:0)\n[ERROR] Failed to load resource: the server responded with a status of 403 () (at https://vercel.com/api/jwt:0:0)\n[WARNING] [GroupMarkerNotSet(crbug.com/242999)!:A0D8980834000000]Automatic fallback to software WebGL has been deprecated. Please use the --enable-unsafe-swiftshader flag to opt in to lower security guarantees for trusted content. (at https://vercel.com/login?next=%2Fsso-api%3Furl%3Dhttps%253A%252F%252Fjob-portal-lgb9-fibzabxg2-arnav4018s-projects.vercel.app%252Fapi%252Fauth%252Fsignin%253Fcsrf%253Dtrue%26nonce%3D13d0f8ec827b015f40578e59916fa75c3b0460312e7fec5a78b68902101a6fbc:0:0)\n[WARNING] The resource https://vercel.com/_next/static/chunks/60dddd4886ec3456.css?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. (at https://vercel.com/login?next=%2Fsso-api%3Furl%3Dhttps%253A%252F%252Fjob-portal-lgb9-fibzabxg2-arnav4018s-projects.vercel.app%252Fapi%252Fauth%252Fsignin%253Fcsrf%253Dtrue%26nonce%3D13d0f8ec827b015f40578e59916fa75c3b0460312e7fec5a78b68902101a6fbc:0:0)\n[WARNING] The resource https://vercel.com/_next/static/chunks/60dddd4886ec3456.css?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. (at https://vercel.com/login?next=%2Fsso-api%3Furl%3Dhttps%253A%252F%252Fjob-portal-lgb9-fibzabxg2-arnav4018s-projects.vercel.app%252Fapi%252Fauth%252Fsignin%253Fcsrf%253Dtrue%26nonce%3D13d0f8ec827b015f40578e59916fa75c3b0460312e7fec5a78b68902101a6fbc:0:0)\n[ERROR] Cross-Origin-Opener-Policy policy would block the window.closed call. (at https://vercel.com/_next/static/chunks/7cc89c37bf1b9466.js?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd:2:0)\n[ERROR] Cross-Origin-Opener-Policy policy would block the window.closed call. (at https://vercel.com/_next/static/chunks/7cc89c37bf1b9466.js?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd:2:0)\n[WARNING] The resource https://vercel.com/_next/static/chunks/60dddd4886ec3456.css?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. (at https://vercel.com/login?next=%2Fsso-api%3Furl%3Dhttps%253A%252F%252Fjob-portal-lgb9-fibzabxg2-arnav4018s-projects.vercel.app%252Fapi%252Fauth%252Fsignin%253Fcsrf%253Dtrue%26nonce%3D13d0f8ec827b015f40578e59916fa75c3b0460312e7fec5a78b68902101a6fbc:0:0)\n[WARNING] The resource https://vercel.com/_next/static/chunks/60dddd4886ec3456.css?dpl=dpl_nwryhHqJkhYV4KK7PQfwGewvzoCd was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. (at https://vercel.com/login?next=%2Fsso-api%3Furl%3Dhttps%253A%252F%252Fjob-portal-lgb9-fibzabxg2-arnav4018s-projects.vercel.app%252Fapi%252Fauth%252Fsignin%253Fcsrf%253Dtrue%26nonce%3D13d0f8ec827b015f40578e59916fa75c3b0460312e7fec5a78b68902101a6fbc:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808006121684//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:46.935Z",
    "modified": "2025-09-02T10:13:26.305Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "f156161a-4eb9-4d5b-8b8b-20ec4a83f9ca",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC004-Role-Based Access Control Enforcement",
    "description": "Verify that users can only access pages and perform actions allowed for their assigned roles.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign In to start login as Candidate\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Candidate email and password and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidatePassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click Sign In again to retry login or verify login state\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Candidate email and password and click Sign In button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidatePassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click Sign In to start login as Recruiter\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Recruiter email and password and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiter@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiterPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to access Admin panel page URL directly\n        await page.goto('http://localhost:3000/admin', timeout=10000)\n        \n\n        # Log out Recruiter user to prepare for Candidate access test to Recruiter job posting page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Access control verification could not be completed as expected.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Role-based access control tests completed for Candidate and Recruiter roles. Candidate login successful and restricted from Recruiter pages. Recruiter login successful and restricted from Admin panel. However, logout functionality is broken, causing 404 error and preventing clean session reset. Recommend fixing logout issue for reliable role-based access testing.\nBrowser Console Logs:\n[WARNING] [Fast Refresh] performing full reload\n\nFast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\nYou might have a file which exports a React component but also exports a value that is imported by a non-React component file.\nConsider migrating the non-React component export to a separate file and importing it into both files.\n\nIt is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\nFast Refresh requires at least one parent function component in your React tree. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js:106:24)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/dashboard/admin:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808291637271//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:46.941Z",
    "modified": "2025-09-02T10:18:11.836Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "6f35bdc8-ea39-4502-b6b5-c6e01aa809ed",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC005-Recruiter Job Posting with AI-Generated Description",
    "description": "Verify that recruiters can create job posts with AI-generated job descriptions, and jobs are saved correctly with company profile and hiring credit wallet checked.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-09-02T10:07:46.949Z",
    "modified": "2025-09-02T10:07:46.949Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "889002b0-e7d5-45b7-937f-b70293633c82",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC006-Job Posting Failure for Insufficient Hiring Credits",
    "description": "Verify job posting is blocked with an error message if the recruiter's hiring credit wallet balance is insufficient.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'I'm Hiring' to proceed to recruiter login or signup.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section[3]/div/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Unable to verify error message due to unknown expected result.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to access recruiter login or job posting page. The job listing page shows an error preventing further progress. Please fix the backend or navigation issues to proceed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756807930753583//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:46.957Z",
    "modified": "2025-09-02T10:12:10.884Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "5b87dd4d-496f-4c46-a830-069081c55505",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC007-Interactive Resume Builder CRUD Operations",
    "description": "Verify candidates can create, read, update, and delete resumes using the interactive resume builder with real-time preview and template selection.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-09-02T10:07:46.964Z",
    "modified": "2025-09-02T10:07:46.964Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "bfb15c59-36ac-4914-9988-3c96b5d977ce",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC008-Resume Builder Auto-Save and Data Loss Prevention",
    "description": "Ensure that the resume builder auto-saves user input periodically and prevents data loss on navigation or unexpected refresh.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'I'm Looking for a Job' to proceed to candidate login or dashboard.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section/div/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill in Full Name, Email, Password fields and submit to create candidate account.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Candidate')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testcandidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sign In' link to go to login page and sign in with created candidate account.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for candidate account and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testcandidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Resume Builder' link in the navigation bar to open the resume builder.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/footer/div/div/div[2]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input candidate email and password and sign in to access resume builder.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testcandidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion as expected result is unknown.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue of sign-in redirection preventing access to resume builder, blocking the auto-save test. Stopping further actions until the issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/auth/signup:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808323156329//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:46.974Z",
    "modified": "2025-09-02T10:18:43.341Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "31b72577-aa69-4f2e-8006-315ea382fe57",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC009-Candidate Profile Management with Document Uploads and Government ID Verification",
    "description": "Verify candidates can upload documents (Aadhar, PAN, UAN), complete government ID verification, and receive updated profile completeness scoring.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign In to start candidate login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input candidate email and password and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('CandidatePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to profile management page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section[5]/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical navigation issue preventing access to profile management page for document upload and verification. Candidate login succeeded but navigation to profile management is broken, blocking further test steps.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808082822617//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.003Z",
    "modified": "2025-09-02T10:14:43.031Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "b78fb2a1-b880-40cc-8301-2185f684bdfb",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC010-Smart Job Search with Multi-Factor AI Filters",
    "description": "Verify candidates can perform job searches using AI-enhanced filters including skills, experience, location, salary, and skill gap analysis.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Sign In' to log in as Candidate.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password, then click Sign In button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('CandidatePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to job search page by clicking 'Browse All Jobs' or 'Jobs' link.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Search Jobs' button to retry loading job listings.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to persistent failure to load job listings on the job search page. The error prevents verification of AI-enhanced filters, dynamic updates, and skill gap analysis features. Issue reported for developer attention.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808103191369//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.010Z",
    "modified": "2025-09-02T10:15:03.509Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "a5c8e9c9-0fb1-4496-9294-1df8f8220912",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC011-Candidate Application and Status Tracking",
    "description": "Verify candidates can apply for jobs, and application statuses are tracked and displayed accurately within candidate dashboards.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign In to log in as Candidate.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sign In' link to start candidate login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input candidate email and password, then click Sign In button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('CandidatePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input job title or keywords and location, then click 'Search Jobs' to find jobs.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Software Engineer')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section/div/div/div/form/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('New York')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to refresh the page or navigate to a different page to reload jobs, or try a different search to see if jobs load.\n        await page.goto('http://localhost:3000/jobs', timeout=10000)\n        \n\n        # Input job title and location, then click 'Search Jobs' to attempt loading jobs again.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Software Engineer')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div/div/form/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('New York')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical failure in job search functionality. Candidate login works, but no jobs load for application. Please fix the job search issue to proceed with testing candidate application and application status tracking.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808232597651//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.017Z",
    "modified": "2025-09-02T10:17:12.800Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "94cedb67-00e8-4005-88f5-941cca889dd5",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC012-Referral System Workflow and Reward Payout",
    "description": "Verify candidates can generate unique referral links, track referral statuses, receive automated rewards, and that payout integration functions correctly.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-09-02T10:07:47.025Z",
    "modified": "2025-09-02T10:07:47.025Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "5e77c4dd-7bab-42ac-bb1c-ca5e1042561f",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC013-Role-Based Dashboard Data Accuracy and Real-Time Updates",
    "description": "Verify that candidates, recruiters, and admins see correct and personalized data on their dashboards, with real-time data updating properly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign In to start login as Candidate\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input candidate email and password and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('candidate@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('CandidatePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on Sign In to start login as Recruiter\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Recruiter email and password, then click Sign In to log in as Recruiter.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiter@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('RecruiterPass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on Sign In to start login as Admin\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Admin email and password, then click Sign In to log in as Admin.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AdminPass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assertions for Candidate dashboard\n        candidate_dashboard = frame.locator('xpath=//div[@id=\"candidate-dashboard\"]')\n        await candidate_dashboard.wait_for(state='visible', timeout=5000)\n        assert await candidate_dashboard.locator('text=Applications').count() > 0\n        assert await candidate_dashboard.locator('text=Match Scores').count() > 0\n        assert await candidate_dashboard.locator('text=Career Insights').count() > 0\n        # Log out candidate\n        logout_button = frame.locator('xpath=//button[text()=\"Logout\"]')\n        await logout_button.click()\n        await page.wait_for_timeout(3000)\n        # Log in as Recruiter assertions\n        recruiter_dashboard = frame.locator('xpath=//div[@id=\"recruiter-dashboard\"]')\n        await recruiter_dashboard.wait_for(state='visible', timeout=5000)\n        assert await recruiter_dashboard.locator('text=Job Posts').count() > 0\n        assert await recruiter_dashboard.locator('text=Application Pipeline').count() > 0\n        assert await recruiter_dashboard.locator('text=Hiring Credits').count() > 0\n        # Log out recruiter\n        await logout_button.click()\n        await page.wait_for_timeout(3000)\n        # Log in as Admin assertions\n        admin_dashboard = frame.locator('xpath=//div[@id=\"admin-dashboard\"]')\n        await admin_dashboard.wait_for(state='visible', timeout=5000)\n        assert await admin_dashboard.locator('text=System Analytics').count() > 0\n        assert await admin_dashboard.locator('text=Feature Flags').count() > 0\n        assert await admin_dashboard.locator('text=User Overview').count() > 0\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808299128262//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.033Z",
    "modified": "2025-09-02T10:18:19.287Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "229399a9-fa15-4363-a4fd-b5d468ed2687",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC014-Admin Panel User Management and Feature Flag Control",
    "description": "Verify admins can manage users (activate, suspend, delete), toggle feature flags, and audit logs accurately record actions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Get Started' or equivalent to proceed to login or admin access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sign In' link to try to access admin login or authentication page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input admin email and password, then click 'Sign In' button to log in as admin.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AdminPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Locate and click on the user management section or admin dashboard link to manage users.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Locate and click on the user management or admin dashboard link to manage users.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Try clicking on 'I'm Hiring' link (index 19) which might lead to employer/admin related dashboard or user management.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section[5]/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking on 'Search Talent' (index 26) or 'Resources' (index 27) under 'For Employers' to locate user management or admin features.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/footer/div/div/div[3]/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to access common admin URLs directly such as '/admin', '/admin/users', or '/dashboard' to locate the admin panel.\n        await page.goto('http://localhost:3000/admin', timeout=10000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Admin login was successful, but the admin dashboard and user management pages are inaccessible, resulting in 404 errors. No user management or feature flag toggling could be tested. Audit logs could not be accessed. Please fix the missing admin interface to enable full testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/talent-search?_rsc=acgkz:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/talent-search:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/dashboard/admin:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808165350924//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.040Z",
    "modified": "2025-09-02T10:16:05.531Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "023e1753-5f69-4d27-9057-2293499b641e",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC015-Interview Management with Scheduling and Reminder Notifications",
    "description": "Verify interview scheduling works with configurable time slots, sends email reminders, and feedback collection is functional.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Sign In' to start login as Recruiter\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Recruiter and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiter@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('SecurePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to find and click on 'Sign In' or 'Recruiter Login' again to retry login or verify login status\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Recruiter and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiter@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('SecurePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try alternative login methods or verify if the Recruiter account exists and is active, or report issue if login is not possible.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to use 'Send magic link to your email' option to login as Recruiter.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiter@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate or confirm login via magic link to access recruiter dashboard and proceed with scheduling interview.\n        await page.goto('http://localhost:3000/recruiter/dashboard', timeout=10000)\n        \n\n        # Navigate back to homepage and try to find alternative navigation or links to recruiter dashboard or jobs page.\n        await page.goto('http://localhost:3000', timeout=10000)\n        \n\n        # Click on 'I'm Hiring' link to try to access recruiter related pages or dashboard.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section[5]/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sign In' link to try to login again or find recruiter dashboard access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Recruiter and click Sign In\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('recruiter@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('SecurePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'I'm Hiring' to access recruiter dashboard or job posting area.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/section[5]/div/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sign In' link to try to login again or find recruiter dashboard access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify interview scheduling with configurable time slots, email reminders, and feedback collection could not be fully completed. Multiple login attempts as Recruiter using email/password and magic link were unsuccessful in accessing the recruiter dashboard or job posting area. Navigation after login leads to recruiter signup page instead of expected recruiter features. No errors or alerts were visible during login attempts. Due to these access issues, scheduling interviews, verifying email reminders, and feedback submission could not be tested. Please verify the recruiter account status and application routing to enable access to recruiter features for further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/recruiter/dashboard:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808422379787//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.048Z",
    "modified": "2025-09-02T10:20:22.545Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "f9fd9937-9818-4de8-865e-fce0d649bdae",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC016-API REST Coverage and Proper Status Codes",
    "description": "Test REST API endpoints for authentication, jobs, resumes, referrals, profiles, admin, and expert consulting to ensure correct responses, data integrity, and status codes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign Up to test signup flow\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill signup form fields with test data and submit to test signup flow\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down to reveal the 'Create Account' button fully and extract all interactive elements to find the correct index for the button\n        await page.mouse.wheel(0, 100)\n        \n\n        # Try to click the 'Create Account' button at index 11 (visible in the viewport) to submit the signup form and test signup flow\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Signup form submission is not working as expected. The form remains on the signup page with no success or error message after clicking 'Create Account'. This prevents further testing of authentication flows. Reporting this issue and stopping the test as per instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/auth/signup:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808312811776//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.097Z",
    "modified": "2025-09-02T10:18:33.079Z"
  },
  {
    "projectId": "5fca55db-2d0b-457c-8fcb-aa6d5aa5312c",
    "testId": "32ae208e-1e84-47f1-8d9e-ab841d7f6f40",
    "userId": "6488a4b8-a0e1-70d8-a744-f91428635632",
    "title": "TC017-Deployment Build and Launch Verification on Vercel",
    "description": "Validate successful build and deployment of the Hirely platform on Vercel environment without errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Sign Up to test the signup flow.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/header/div/div[2]/div/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Fill signup form with test user data and submit to test signup flow.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down to reveal the 'Create Account' button fully and try to click it by searching for the button text or by clicking the closest interactive element index 0 or 1 if they correspond to the button.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click on the 'Sign in' link to test the login flow as an alternative smoke test.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Create Account' button to submit the signup form and verify successful account creation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/main/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to signup form submission failure. The 'Create Account' button does not work as expected, blocking further smoke tests. Issue reported for developer investigation.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/auth/signup:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/6488a4b8-a0e1-70d8-a744-f91428635632/1756808380817308//tmp/test_task/result.webm",
    "created": "2025-09-02T10:07:47.104Z",
    "modified": "2025-09-02T10:19:40.991Z"
  }
]
